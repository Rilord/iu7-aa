\chapter{Технологический раздел}

В данном разделе будут приведены требования к ПО, средства его реализации и листинга кода алгоритмов, а также рассмотрены тестовые случаи.

\section{Средства реализации} 

Для реализации программ я выбрал язык программирования Python, так как я очень хорошо знаком c этим языком и пишу на нем давно, также этот язык является удобным, безопасным и в нем присутствуют инструменты замера времени.

\section{Листинги кода}

Листинги 3.1 - 3.3 демонстрируют реализацию алгоритмов умножения матриц.

\captionsetup{singlelinecheck = false, justification=raggedright}
\begin{lstlisting}[label=multStand, caption=Стандартный алгоритм умножения матриц]
def defaultMatrixMul(left_matrix: list, right_matrix: list) -> list:
    if len(left_matrix) == 0 or len(right_matrix) == 0:
        print("Matrices are empty")
    elif len(left_matrix[0]) != len(right_matrix):
        print("Matrices cannot be multiplied")
    else:
        res_matrix = [
            [0 for _ in range(len(right_matrix[i]))] for i in \
            range(len(left_matrix))
        ]

        for i in range(len(left_matrix)):
            for j in range(len(right_matrix[i])):
                for k in range(len(left_matrix[i])):
                    res_matrix[i][j] += left_matrix[i][k] * \
                                        right_matrix[k][j]

        return res_matrix
    return
\end{lstlisting}

\begin{lstlisting}[label=multVin, caption=Алгоритм умножения матриц Винограда]
def vinMatrixMul(left_matrix: list, right_matrix: list) -> list:
    if len(left_matrix) == 0 or len(right_matrix) == 0:
        print("Matrices are empty")
    elif len(left_matrix[0]) != len(right_matrix):
        print("Matrices cannot be multiplied")
    else:
        left_matrix_rows = len(left_matrix)
        left_matrix_columns = len(left_matrix[0])
        right_matrix_columns = len(right_matrix[0])

        res_matrix = [
            [0 for _ in range(right_matrix_columns)] for _ in \
                                      range(left_matrix_rows)
        ]

        row_factor = [0 for _ in range(left_matrix_rows)]
        for i in range(left_matrix_rows):
            for j in range(left_matrix_columns // 2):
                row_factor[i] += left_matrix[i][2 * j] * \
                                 left_matrix[i][2 * j + 1]

        column_factor = [0 for _ in range(right_matrix_columns)]
        for i in range(right_matrix_columns):
            for j in range(left_matrix_columns // 2):
                column_factor[i] += right_matrix[2 * j][i] * \
                                    right_matrix[2 * j + 1][i]

        for i in range(left_matrix_rows):
            for j in range(right_matrix_columns):
                res_matrix[i][j] = -row_factor[i] - column_factor[j]
                for u in range(left_matrix_columns // 2):
                    res_matrix[i][j] += (
                        left_matrix[i][2 * u + 1] + right_matrix[2 * u][j]
                    ) * (left_matrix[i][2 * u] + \
                        right_matrix[2 * u + 1][j])

        if left_matrix_columns % 2 == 1:
            for i in range(left_matrix_rows):
                for j in range(right_matrix_columns):
                    res_matrix[i][j] += (
                        left_matrix[i][left_matrix_columns - 1]
                        * right_matrix[left_matrix_columns - 1][j]
                    )

        return res_matrix
    return
\end{lstlisting}

\begin{lstlisting}[label=multVinOptimize, caption=Алгоритм умножения матриц Винограда (оптимизированный)]
def optimizedVinMatrixMul(left_matrix: list, right_matrix: list) -> list:
    if len(left_matrix) == 0 or len(right_matrix) == 0:
        print("Matrices are empty")
    elif len(left_matrix[0]) != len(right_matrix):
        print("Matrices cannot be multiplied")
    else:
        left_matrix_rows = len(left_matrix)
        left_matrix_columns = len(left_matrix[0])
        right_matrix_columns = len(right_matrix[0])

        res_matrix = [
            [0 for _ in range(right_matrix_columns)] for _ in \
                                        range(left_matrix_rows)
        ]

        row_factor = [0 for _ in range(left_matrix_rows)]
        for i in range(left_matrix_rows):
            for j in range(1, left_matrix_columns, 2):
                row_factor[i] += left_matrix[i][j] * left_matrix[i][j - 1]

        column_factor = [0 for _ in range(right_matrix_columns)]
        for i in range(right_matrix_columns):
            for j in range(1, left_matrix_columns, 2):
                column_factor[i] += right_matrix[j][i] * \
                                    right_matrix[j - 1][i]

        flag = left_matrix_rows % 2
        for i in range(left_matrix_rows):
            for j in range(right_matrix_columns):
                res_matrix[i][j] = -(row_factor[i] + column_factor[j])
                for u in range(1, left_matrix_columns, 2):
                    res_matrix[i][j] += (left_matrix[i][u - 1] + \
                                           right_matrix[u][j]) * (
                        left_matrix[i][u] + right_matrix[u - 1][j]
                    )
                if flag:
                    res_matrix[i][j] += (
                        left_matrix[i][left_matrix_columns - 1]
                        * right_matrix[left_matrix_columns - 1][j]
                    )

        return res_matrix
    return
\end{lstlisting}
\captionsetup{singlelinecheck = false, justification=centering}

\section{Тестирование ПО}

В таблице 3.1 приведены тестовые случаи для алгоритмов умножения матриц. Случаи 1 - 2 - умножение однострочных/одностолбцовых матриц, 3 - 5 - матрицы одного размера, 6 - некорректный размер.

\begin{table}[H]
	\begin{center}
		\captionsetup{singlelinecheck = false, justification=centering}
		\caption{Тестовые случаи}
		\begin{tabular}{l|l|l|l}
			N & Матрица 1 & Матрица 2 & Результат \\ 
			\hline
			\vspace{2mm}
			\vspace{2mm}
			1 & $\begin{pmatrix}
				1 & 1 & 1\\
				2 & 2 & 2\\
				3 & 3 & 3
			\end{pmatrix}$ &
			$\begin{pmatrix}
				1 \\
				1 \\
				1 
			\end{pmatrix}$ &
			$\begin{pmatrix}
				3 \\
				6 \\
				9
			\end{pmatrix}$ \\
			\vspace{2mm}
			\vspace{2mm}
			2 & $\begin{pmatrix}
				1 & 1 & 1
			\end{pmatrix}$ &
			$\begin{pmatrix}
				1 \\
				1 \\
				1
			\end{pmatrix}$ &
			$\begin{pmatrix}
				3
			\end{pmatrix}$ \\
			\vspace{2mm}
			\vspace{2mm}
			3 & $\begin{pmatrix}
				1 & 1 \\
				1 & 1
			\end{pmatrix}$ &
			$\begin{pmatrix}
				1 & 1\\
				1 & 1
			\end{pmatrix}$ &
			$\begin{pmatrix}
				2 & 2\\
				2 & 2
			\end{pmatrix}$ \\
			\vspace{2mm}
			\vspace{2mm}
			4 & $\begin{pmatrix}
				3
			\end{pmatrix}$ &
			$\begin{pmatrix}
				3
			\end{pmatrix}$ &
			$\begin{pmatrix}
				9
			\end{pmatrix}$ \\
			\vspace{2mm}
			\vspace{2mm}
			5 & $\begin{pmatrix}
				1 & 2 & 3\\
				4 & 5 & 6\\
				7 & 8 & 9
			\end{pmatrix}$ &
			$\begin{pmatrix}
				7 & 8 & 9\\
				4 & 5 & 6\\
				1 & 2 & 3
			\end{pmatrix}$ &
			$\begin{pmatrix}
				18 & 24 & 30\\
				54 & 69 & 84\\
				90 & 114 & 138
			\end{pmatrix}$\\
			\vspace{2mm}
			\vspace{2mm}
			6 & $\begin{pmatrix}
				2 & 3
			\end{pmatrix}$ &
			$\begin{pmatrix}
				4 & 5
			\end{pmatrix}$ &
			Некорректный размер\\
		\end{tabular}
	\end{center}
\end{table}

\section{Вывод}

В данном разделе были представлены выбор языка программирования, листинги реализаций алгоритмов и результаты тестирования.