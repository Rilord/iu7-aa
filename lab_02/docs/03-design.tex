\chapter{Конструкторский раздел}

В данном разделе будут спроектированы схемы алгоритмов, произведена оценка трудоемкости алгоритмов, описаны используемые типы данных, а также произведена оценка памяти и описана структура ПО.

\section{Схемы алгоритмов}

На рисунках 2.1 - 2.2 представлены схемы рассматриваемых алгоритмов.
 
\newpage
\begin{figure}[h!]
	\begin{center}
		\includegraphics[scale=0.6]{assets/multStand.png}
	\end{center}
	\caption{Схема стандартного алгоритма умножения матриц}
\end{figure}

\newpage 
\begin{figure}[h!]
	\begin{center}
		\includegraphics[scale=0.6]{assets/multVin.png}
	\end{center}
	\caption{Схема алгоритма умножения матриц Винограда}
\end{figure}

\newpage
\section{Модель оценки трудоемкости алгоритмов}

\subsection{Трудоемкость алгоритмов}

Введем модель оценки трудоемкости.

\begin{enumerate}
	\item Трудоемкость базовых операций
		\begin{itemize}
			\item Примем трудоемкость следующих операций равной 1:
			\begin{equation}
				=, +, -, +=, -=, ==, !=, <, >, \leq, \geq, !, \&\&, ||, []
			\end{equation}
			\item Примем трудоемкость следующих операций равной 2:
			\begin{equation}
				*, /, \%, *=, /=,
			\end{equation}
		\end{itemize}
	\item Трудоемкость циклов
	\begin{equation}
		f = f_{init} + f_{compare} + N_{iter} * (f_{body} + f_{inc} + f_{compare})
	\end{equation}
	\item Трудоемкость условного оператора
		Пусть трудоемкость самого условного перехода равна 0. Тогда
		\begin{equation}
			f_{if} = f_{condition} + 
			\begin{sqcases}
				min(f_{true}, f_{false}), \text{в лучшем случае}\\
				max(f_{true}, f_{false}), \text{в худшем случае}\\				
			\end{sqcases}
		\end{equation}
\end{enumerate}

где \newline
$f_{init}$ - трудоемкость инициализации, \newline
$f_{compare}$ - трудоемкость сравнения, \newline
$N_{iter}$ - количество итераций, \newline
$f_{body}$ - трудоемкость тела цикла, \newline
$f_{inc}$ - трудоемкость инкрементации, \newline
$f_{condition}$ - трудоемкость условия, \newline
$f_{true}$, $f_{false}$ - трудоемкость веток условного оператора.
\newpage

\subsection{Трудоемкость стандартного алгоритма}

Обозначу псевдонимы к переменным для краткого обращения:
\begin{itemize}
	\item L = len(left\_matrix);
	\item N = len(right\_matrix[i];
	\item M = len(left\_matrix[i]).
\end{itemize}

Трудоемкость стандартного алгоритма состоит из:
\begin{itemize}
	\item трудоемкость цикла по i от 1 до L: $f = 2 + L(2 + f_{body})$;
	\item трудоемкость цикла по j от 1 до N: $f = 2 + 3 + N(2 + f_{body})$;
	\item трудоемкость цикла по k от 1 до M: $f = 2 + M(2 + 12) = 2 + 14M$.
\end{itemize}

Итого, трудоемкость стандартного алгоритма равна:
\begin{equation}
    f = 2 + L(2 + 2 + N(2 + 3 + 2 + 14M)) = 2 + 4L + 7LN + 14LNM \approx 14LNM \approx O(N^3)
\end{equation}

\subsection{Трудоемкость алгоритма Винограда}

Обозначу псевдонимы к переменным для краткого обращения:
\begin{itemize}
	\item L = len(left\_matrix);
	\item N = len(right\_matrix[i];
	\item M = len(left\_matrix[i]).
	\item R = row\_factor.
	\item C = column\_factor.
\end{itemize}

Трудоемкость алгоритма Винограда состоит из:
\begin{itemize}
    \item аллокация и инициализация векторов R и C: $f_{RC} = L + N + 2 + L(2 + 3 + \frac{1}{2}M(3 + 14)) + 2 + N(2 + 3 + \frac{1}{2}M(3 + 14)) = 2 + 6L + 6N + \frac{17}{2}LM + \frac{17}{2}NM$;
    \item цикл по i от 1 до L: $f_{L} = 2 + L(2 + f_{body})$;
    \item цикл по j от 1 до N: $f_{N} = 2 + N(2 + 7 + f_{body})$;
    \item цикл по u от 1 до M/2: $f_{M/2} = 3 + \frac{1}{2}M(3 + 28) = 3 + \frac{31}{2}M$;
    \item проверка размеров на нечетность:
    \begin{equation}
    	f_{if} = 3 + \begin{sqcases}
    			0, & \text{л.с.}\\
    			2 + L(2 + 2 + N(2 + 11)) & \text{х.с.}\\
    		\end{sqcases}
    \end{equation}
\end{itemize}

Итого, трудоемкость алгоритма Винограда для лучшего случая равна:
\begin{equation}
	f = 4 + 10L + 6N + \frac{17}{2}LM + \frac{17}{2}NM + 12LN + \frac{31}{2}LNM \approx 15,5LNM \approx O(N^3)
\end{equation}

Для худшего случая равна:
\begin{equation}
	f = 6 + 14L + 6N + \frac{17}{2}LM + \frac{17}{2}NM + 25LN + \frac{31}{2}LNM \approx 15,5LNM \approx O(N^3)
\end{equation}

\subsection{Трудоемкость оптимизированного алгоритма Винограда}

Обозначу псевдонимы к переменным для краткого обращения:
\begin{itemize}
	\item L = len(left\_matrix);
	\item N = len(right\_matrix[i];
	\item M = len(left\_matrix[i]).
	\item R = row\_factor.
	\item C = column\_factor.
\end{itemize}

Трудоемкость оптимизированного алгоритма Винограда состоит из:
\begin{itemize}
    \item аллокация и инициализация векторов R и C: $f_{RC} = L + N + 2 + L(2 + 3 + \frac{1}{2}M(3 + 13)) + 2 + N(2 + 3 + \frac{1}{2}M(3 + 13)) = 2 + 6L + 6N + 8LM + 8NM$;
    \item цикл по i от 1 до L: $f_{L} = 2 + L(2 + f_{body})$;
    \item цикл по j от 1 до N: $f_{N} = 2 + N(2 + 5 + f_{body} + f_{if} + 3)$;
    \item цикл по k от 1 до M/2: $f_{M/2} = 3 + \frac{1}{2}M(3 + 23) = 3 + 13M$;
    \item проверка размеров на нечетность:
    \begin{equation}
    	f_{if} = 3 + \begin{sqcases}
    			0, & \text{л.с.}\\
    			10 & \text{х.с.}\\
    		\end{sqcases}
    \end{equation}
\end{itemize} 

Итого, трудоемкость оптимизированного алгоритма Винограда для лучшего случая равна:
\begin{equation}
	f = 4 + 10L + 6N + 8LM + 8NM + 16LN + 13LNM \approx 13LNM \approx O(N^3)
\end{equation}

Для худшего случая равна:
\begin{equation}
	f = 4 + 10L + 6N + 8LM + 8NM + 26LN + 13LNM \approx 13LNM \approx O(N^3)
\end{equation}

\section{Описание используемых типов данных}

При реализации алгоритмов будут использованы следующие структуры данных:
\begin{itemize}
	\item матрица типа int заданного размера;
	\item размеры матрицы - целое число int;
	\item вспомогательные массивы типа int заданного размера.
\end{itemize}

\section{Описание выделенных классов эквивалентности}

Для дальнейшего тестирования работы программы были выделены следующие классы эквивалентности:
\begin{itemize}
	\item квадратная матрица четных размеров;
	\item квадратная матрица нечетных размеров.
\end{itemize}

\section{Структура ПО}

ПО будет состоять из следующих модулей:
\begin{itemize}
	\item main.py - модуль, вызывающий загрузку меню (является модулем запуска);
	\item menu.py - модуль, содержащий меню пользователя;
	\item myio.py - модуль, содержащий функции формирования матриц;
	\item muls.py - модуль, содержащий функции перемножения матриц;
	\item plot.py - модуль, содержащий функции для построения графиков сложности перемножения матриц.
\end{itemize}

\section{Вывод}

На основе полученных в аналитическом разделе знаний об алгоритмах были спроектированы схемы алгоритмов, произведена оценка их трудоемкости, выбраны используемые типы данных, проведена оценка затрачиваемого объема памяти, а также описана структура ПО.